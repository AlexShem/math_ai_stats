---
title: "Оценка справедливости монеты"
author: "Александр Шемендюк"
date: "2024-11-13"
toc: true
format:
    html:
        number-sections: false
        toc-depth: 2
        html-math-method: katex
        self-contained: true
        monofont: JetBrains Mono
        code-overflow: scroll
        code-tools: true
        code-line-numbers: true
        code-annotations: below
jupyter: python3
---

# Оценка справедливости монеты

Предположим, нам дали монету, но мы не знаем, справедлива она или нет. То есть мы не знаем, равна ли вероятность выпадения орла 50%, или же монета смещена в сторону орла или решки. Наша цель — оценить вероятность выпадения орла, подбрасывая монету многократно и анализируя результаты.

В этом занятии мы проведем эксперименты, подбрасывая монету столько раз, сколько захотим, и будем наблюдать, как улучшается наша оценка по мере увеличения числа подбрасываний.

## Шаг 1: Несколько подбрасываний монеты

Сначала давайте подбросим монету небольшое количество раз, скажем, 10 раз, и запишем результаты.

Мы будем использовать функцию `flip_coin`, которая симулирует подбрасывание монеты. Эта функция возвращает `1`, если выпал орел, и `0`, если выпала решка.

Вот код для функции `flip_coin`:

![`flip_coin()` Function Documentation](coin_flip_documentation.png)

```{python}
#| code-fold: true
#| code-summary: coinflip.py модуль создержащий функцию flip_coin().

import numpy as np  # Импортируем NumPy для численных операций

# Вероятность выпадения орла (нам неизвестна)
PROBABILITY_HEAD = 0.54

def flip_coin(p=None):
    """Random coin flip.

    The function flips a coin (possibly, *unfair*) and returns:

    - 1, if the coin lands on `head`,
    - 0, if the coin lands on `tail`.

    Example usage:

    >>> flip = flip_coin(0.5)

    Output:

    >>> print(flip)
    >>> 1  # May vary

    :param p: Probability of the coin to land on `head`. Should be in [0, 1].
    :type p: float
    :return: (int): ``1`` if `head` and ``0`` if `tail`.
    :rtype: int
    """
    if p is None:
        p = PROBABILITY_HEAD

    if p > 1.0 or p < 0.0:
        raise ValueError(f"Parameter `p` should be in [0, 1]. Got {p} instead.")

    return 1 if np.random.rand() <= p else 0
```

**Примечание:** В реальной ситуации мы не знали бы значение `PROBABILITY_HEAD`. В нашей симуляции это истинная вероятность выпадения орла, но мы делаем вид, что не знаем ее.

Теперь подбросим монету 10 раз и запишем результаты:

```{python}
# Количество подбрасываний монеты
N_FLIPS = 10

# Подбрасываем монету N_FLIPS раз
coin_flips = [flip_coin() for _ in range(N_FLIPS)]  # <1>

# Вычисляем оценочную вероятность выпадения орла
head_probability = sum(coin_flips) / N_FLIPS

print(f"Оценка вероятности выпадения орла после {N_FLIPS} подбрасываний: {head_probability:.4f}")
```
1. Пример генератора списка в Python для подбрасывания монеты `N_FLIPS` раз и сохранения результатов в списке.

С всего 10 подбрасываниями наша оценка может быть не очень точной. Давайте посмотрим, как она улучшается по мере увеличения числа подбрасываний.

## Шаг 2: Увеличиваем количество подбрасываний

Чтобы улучшить нашу оценку, мы можем увеличить количество подбрасываний монеты. Согласно **закону больших чисел**, по мере увеличения числа испытаний (подбрасываний монеты) наша оценка вероятности должна приближаться к истинной вероятности.

Давайте проведем эксперименты с увеличивающимся количеством подбрасываний: 10, 100, 1'000, 10'000 и 100'000.

Для каждого количества подбрасываний мы повторим эксперимент несколько раз (скажем, 20 раз), чтобы получить среднюю оценку, а также максимальные и минимальные значения.

Вот код для проведения этих экспериментов:

```{python}
def run_experiments(n_flips, n_experiments, p=None):
    """
    Запускает несколько экспериментов по подбрасыванию монеты.

    :param n_flips: (int): Количество подбрасываний в каждом эксперименте.
    :param n_experiments: (int): Количество экспериментов для запуска.
    :param p: (float, optional): Вероятность выпадения орла.

    :return: list[float]: Список оценок вероятностей из каждого эксперимента.
    """
    estimated_probabilities = []  # <1>
    for _ in range(n_experiments):
        flips = [flip_coin(p) for _ in range(n_flips)]  # <2>
        probability_estimate = sum(flips) / n_flips
        estimated_probabilities.append(probability_estimate)
    return estimated_probabilities
```
1. Список для хранения оценок вероятности из каждого эксперимента.
2. Еще один генератор списка для подбрасывания монеты `n_flips` раз в каждом эксперименте и сохранения результатов в списке.

Теперь запустим эксперименты:

```{python}
N_EXPERIMENTS = 20  # Количество экспериментов для каждого количества подбрасываний
n_flips_list = [10, 100, 1000, 10000, 100000]  # Различные количества подбрасываний

avg_probabilities = []
max_probabilities = []
min_probabilities = []

for n_flips in n_flips_list:
    # Запускаем эксперименты
    probabilities = run_experiments(n_flips, N_EXPERIMENTS)
    
    # Вычисляем статистику
    average_p = sum(probabilities) / N_EXPERIMENTS
    max_p = max(probabilities)
    min_p = min(probabilities)
    
    # Добавляем в списки
    avg_probabilities.append(average_p)
    max_probabilities.append(max_p)
    min_probabilities.append(min_p)
    
    # Выводим результаты
    print(f"\nОценока вероятности выпадения орла для {n_flips} подбрасываний:")
    print(f"Среднее: {average_p:.4f}")
    print(f"Максимум: {max_p:.4f}")
    print(f"Минимум: {min_p:.4f}")
```

Мы можем наблюдать, как оценка вероятности выпадние орла приближается к истинной вероятности (которая равна 0.54) по мере увеличения числа подбрасываний. Разница между максимальными и минимальными значениями оценки также становится меньше, что указывает на более стабильные результаты.

## Шаг 3: Визуализация результатов

Чтобы лучше понять, как улучшается наша оценка, давайте построим график средних, максимальных и минимальных оценок вероятности для каждого количества подбрасываний.

```{python}
import matplotlib.pyplot as plt  # Импортируем Matplotlib для построения графиков

plt.figure(figsize=(10, 6))
plt.semilogx(n_flips_list, avg_probabilities, label='Среднее', marker='o')
plt.semilogx(n_flips_list, max_probabilities, label='Максимум', linestyle='--', color='red', marker='x')
plt.semilogx(n_flips_list, min_probabilities, label='Минимум', linestyle='--', color='green', marker='x')
plt.xlabel('Количество подбрасываний монеты')
plt.ylabel('Оценка вероятности выпадения орла')
plt.title('Оценка вероятности орла при разном количестве подбрасываний монеты')
plt.legend()
plt.grid(True)
plt.show()
```

Этот график показывает, как средняя оценока вероятности стремится к истинной вероятности (0.54) по мере увеличения числа подбрасываний монеты. Максимальные и минимальные значения оценки также приближаются к среднему, указывая на то, что оценки становятся более стабильными при большем числе испытаний.

## Заключение

В ходе этого эксперимента мы увидели, как увеличение количества подбрасываний монеты улучшает нашу оценку ее справедливости. Это демонстрирует **закон больших чисел**, который гласит, что по мере увеличения числа испытаний, экспериментальная вероятность приближается к теоретической.

Подбрасывая монету большее число раз, мы можем получить более точную оценку истинной вероятности выпадения орла. В реальных ситуациях этот метод **фундаментален в статистике и теории вероятностей**, помогая нам делать прогнозы на основе эмпирических данных.

---

**Ключевые моменты:**

- **Экспериментальная вероятность:** Отношение числа случаев наступления события к общему числу испытаний (или проведенных действий).
- **Закон больших чисел:** Принцип теории вероятностей и статистики, который утверждает, что по мере увеличения числа испытаний экспериментальная вероятность стремится к теоретической (истинной) вероятности.
- **Симуляция:** Использование случайной выборки для моделирования и изучения поведения реальных систем или процессов.

**Вопросы для дальнейшего размышления:**

1. Как изменились бы результаты, если бы монета была справедливой (вероятность орла 0.5)?
2. Что произойдет, если мы используем смещенную монету с гораздо более высокой или низкой вероятностью выпадения орла?
3. Как этот эксперимент помогает нам понять реальные приложения, такие как опросы общественного мнения или прогнозирование результатов на основе выборок?
