# Генерация случайных чисел и визуализация их распределений

## Введение

В этом файле мы упростим поставленные задачи и сделаем их более понятными. Мы будем использовать Python (с библиотеками `numpy` для генерации случайных чисел и `matplotlib` для построения графиков), чтобы:

1. Генерировать равномерно распределённые случайные числа и использовать их для моделирования дискретных случайных величин (например, подбрасывание монеты или бросок кубика).
2. Создавать и понимать гистограммы для таких дискретных исходов.
3. Генерировать нормально распределённые случайные величины, строить для них гистограммы и добавлять сглаженную оценку плотности.
4. Объединять две выборки из разных нормальных распределений и изучать их совокупное распределение с помощью оценки плотности, чтобы увидеть две вершины.

Мы будем пошагово объяснять каждое действие и показывать примеры кода. Запускайте ячейки по очереди и наблюдайте за результатами.

---

## Задача 1: Генерация равномерных случайных чисел и моделирование дискретных исходов

**Цель:**

- Сгенерировать равномерные случайные числа из интервала [0,1].
- Использовать эти числа для моделирования подбрасывания монеты и броска кубика.

### Что такое равномерное распределение?

Равномерное распределение на [0,1] означает, что каждое число от 0 до 1 равновероятно. Если мы сгенерируем много таких чисел, примерно половина окажется меньше 0.5, а половина больше 0.5.

### Шаги

1. **Генерация равномерных чисел**:  
   Используем `numpy.random.rand(n)` для генерации `n` равномерных чисел на [0,1].

   ```python
   import numpy as np

   # Генерируем 1000 равномерных чисел
   u = np.random.rand(1000)
   ```

2. **Моделирование подбрасывания монеты**:  
   Если `u[i] < 0.5`, считаем результат «орёл» (обозначим 0), иначе «решка» (обозначим 1).

   ```python
   coin_flips = (u < 0.5).astype(int)  # 0 - орёл, 1 - решка
   ```

3. **Проверяем частоты**:  
   Подсчитаем количество орлов и решек:

   ```python
   heads_count = np.sum(coin_flips == 0)
   tails_count = np.sum(coin_flips == 1)
   print("Орёл:", heads_count, "Решка:", tails_count)
   ```

4. **Моделирование броска кубика**:  
   Чтобы получить число от 1 до 6, можно умножить `u` на 6, преобразовать к целому, а потом добавить 1.

   ```python
   dice_rolls = (u * 6).astype(int) + 1
   ```

5. **Проверим частоты для кубика**:

   ```python
   for face in range(1, 7):
       count = np.sum(dice_rolls == face)
       print(f"Грань {face}: {count}")
   ```

---

## Задача 2: Построение гистограмм

**Цель:**  
Научиться строить гистограммы для дискретных исходов (результаты подбрасываний монетки и бросков кубика).

**Гистограмма** – это столбиковая диаграмма, показывающая как часто встречаются разные значения.

### Шаги

1. **Подключаем Matplotlib**:

   ```python
   import matplotlib.pyplot as plt
   ```

2. **Гистограмма для подбрасываний монетки**:

   ```python
   plt.hist(coin_flips, bins=[-0.5,0.5,1.5], edgecolor='black', align='mid')
   plt.xticks([0,1], ["Орёл","Решка"])
   plt.title("Результаты подбрасывания монеты")
   plt.xlabel("Исход")
   plt.ylabel("Частота")
   plt.show()
   ```

3. **Гистограмма для бросков кубика**:

   ```python
   plt.hist(dice_rolls, bins=np.arange(0.5,7.5,1), edgecolor='black', align='mid')
   plt.xticks([1,2,3,4,5,6])
   plt.title("Результаты броска кубика")
   plt.xlabel("Исход")
   plt.ylabel("Частота")
   plt.show()
   ```

Запустив эти команды, вы увидите столбики, показывающие, сколько раз выпал каждый исход.

---

## Задача 3: Симуляция нормального распределения, гистограмма и плотность

**Цель:**

- Сгенерировать данные из нормального распределения с параметрами (среднее = 0, стандартное отклонение = 1).
- Построить гистограмму.
- Добавить теоретическую плотность нормального распределения (кривую).

### Пояснение

**Нормальное распределение** часто называют «колоколообразным». `np.random.randn(n)` генерирует `n` чисел из стандартного нормального распределения (среднее 0, стандартное отклонение 1).

### Шаги

1. **Генерация нормальных данных**:

   ```python
   data = np.random.randn(1000)  # N(0,1)
   ```

2. **Гистограмма с нормальными данными**:

   ```python
   plt.hist(data, bins=30, density=True, alpha=0.6, color='g', edgecolor='black')
   plt.title("Гистограмма нормального распределения")
   plt.xlabel("Значение")
   plt.ylabel("Плотность")
   plt.show()
   ```

   `density=True` нормализует гистограмму, чтобы площадь под ней была равна 1.

3. **Добавление теоретической плотности**:

   Используем `scipy.stats.norm.pdf` для получения теоретической кривой плотности.

   ```python
   from scipy.stats import norm

   x = np.linspace(-4,4,100)
   pdf = norm.pdf(x, loc=0, scale=1)

   plt.hist(data, bins=30, density=True, alpha=0.6, color='g', edgecolor='black')
   plt.plot(x, pdf, 'r-', lw=2)
   plt.title("Нормальное распределение с теоретической плотностью")
   plt.xlabel("Значение")
   plt.ylabel("Плотность")
   plt.show()
   ```

---

## Задача 4: Две нормальные выборки и две вершины

**Цель:**

- Сгенерировать две выборки из нормальных распределений с разными средними.
- Объединить их.
- Построить гистограмму и оценку плотности, чтобы увидеть две вершины.

### Шаги

1. **Генерация двух выборок**:
   - Первая: N(-2, 1)
   - Вторая: N(2, 1)

   ```python
   data1 = np.random.randn(1000)*1 + (-2)
   data2 = np.random.randn(1000)*1 + ( 2)
   combined_data = np.concatenate([data1, data2])
   ```

2. **Гистограмма объединённых данных**:

   ```python
   plt.hist(combined_data, bins=30, density=True, alpha=0.6, edgecolor='black')
   plt.title("Гистограмма объединённых данных")
   plt.xlabel("Значение")
   plt.ylabel("Плотность")
   plt.show()
   ```

   Вполне возможно, что не сразу будет видно две вершины.

3. **Оценка плотности ядром (KDE)**:

   Используем `scipy.stats.gaussian_kde`, чтобы получить гладкую оценку плотности.

   ```python
   from scipy.stats import gaussian_kde

   kde = gaussian_kde(combined_data)
   x_vals = np.linspace(-6,6,200)
   density_vals = kde(x_vals)

   plt.hist(combined_data, bins=30, density=True, alpha=0.6, edgecolor='black')
   plt.plot(x_vals, density_vals, 'r-', lw=2)
   plt.title("Объединённое распределение с оценкой плотности")
   plt.xlabel("Значение")
   plt.ylabel("Плотность")
   plt.show()
   ```

   Теперь вы должны увидеть две отдельные вершины (два пика), которые отражают два объединённых нормальных распределения.

---

## Итоги

В этом файле мы пошагово рассмотрели:

- Генерацию равномерных и нормальных случайных чисел.
- Использование равномерного распределения для моделирования дискретных исходов (монета, кубик).
- Построение гистограмм для наглядного представления частот или плотностей.
- Добавление теоретической кривой плотности для нормального распределения.
- Объединение двух нормальных выборок и анализ полученного распределения с использованием оценки плотности, чтобы увидеть две вершины.

Запуская эти примеры кода по очереди и изучая результаты, вы лучше поймёте, как работать со случайными данными и визуализировать их распределения.
