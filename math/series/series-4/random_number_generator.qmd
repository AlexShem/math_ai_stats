---
title: "Генерация случайных чисел и визуализация их распределений"
subtitle: "Использование `numpy` и `matplotlib` для симуляций"
toc: true
toc-depth: 1
format: 
  html:
    number-sections: false
    html-math-method: katex
    self-contained: true
    monofont: JetBrains Mono
    code-overflow: wrap
    code-tools: true
    code-link: true
format-links: false
jupyter: python3
---

## Введение

В этом файле мы упростим поставленные задачи и сделаем их более понятными. Мы будем использовать Python (с библиотеками `numpy` для генерации случайных чисел и `matplotlib` для построения графиков), чтобы:

1. Генерировать равномерно распределённые случайные числа и использовать их для моделирования дискретных случайных величин (например, подбрасывание монеты или бросок кубика).
2. Создавать и понимать гистограммы для таких дискретных исходов.
3. Генерировать нормально распределённые случайные величины, строить для них гистограммы и добавлять сглаженную оценку плотности.
4. Объединять две выборки из разных нормальных распределений и изучать их совокупное распределение с помощью оценки плотности, чтобы увидеть две вершины.

Мы будем пошагово объяснять каждое действие и показывать примеры кода. Запускайте ячейки по очереди и наблюдайте за результатами.

---

## Задача 1: Генерация равномерных случайных чисел и моделирование дискретных исходов

**Цель:**

- Сгенерировать равномерные случайные числа из интервала [0,1].
- Использовать эти числа для моделирования подбрасывания монеты и броска кубика.

### Что такое равномерное распределение?

Равномерное распределение на [0,1] означает, что каждое число от 0 до 1 равновероятно. Если мы сгенерируем много таких чисел, примерно половина окажется меньше 0.5, а половина больше 0.5.

### Шаги

1. **Генерация равномерных чисел**:  
   Создадим генератор случайных чисел и сгенерируем 1000 равномерных чисел. 
   
   - Генератор случайных чисел `np.random.default_rng(seed=827401831)` создаётся с фиксированным начальным значением (зерном `seed`), чтобы результаты были воспроизводимыми. Зерно можно изменить на другое целое число, чтобы получить другие случайные числа, или оставить его пустым, чтобы использовать текущее время.
      - `np.random.default_rng()` создаёт генератор случайных чисел с текущим временем в качестве зерна.
      - `np.random.default_rng(seed=827401831)` создаёт генератор с фиксированным зерном 827401831.
      - См. [документацию `numpy.random.default_rng()`](https://numpy.org/doc/stable/reference/random/generator.html) для дополнительных параметров.
   - Далее, с помощью `rng.random(1000)` получаем 1000 равномерных чисел.
      - `rng.random()` возвращает случайное число из интервала [0,1).
      - `rng.random(1000)` возвращает массив из 1000 случайных чисел.
      - См. [документацию `numpy.random.Generator.random()`](https://numpy.org/doc/stable/reference/random/generated/numpy.random.Generator.random.html) для дополнительных параметров.

   ```{python}
   import numpy as np

   rng = np.random.default_rng(seed=827401831)

   # Генерируем 1000 равномерных чисел
   u = rng.random(1000)
   ```

2. **Моделирование подбрасывания монеты**:  
   Если `u[i] < 0.5`, считаем результат «орёл» (обозначим 0), иначе «решка» (обозначим 1).

   ```{python}
   coin_flips = (u < 0.5).astype(int)  # 0 - орёл, 1 - решка
   ```

3. **Проверяем частоты**:  
   Подсчитаем количество орлов и решек:

   ```{python}
   heads_count = np.sum(coin_flips == 0)
   tails_count = np.sum(coin_flips == 1)
   print("Орёл:", heads_count, "Решка:", tails_count)
   ```

4. **Моделирование броска кубика**:  
   Чтобы получить число от 1 до 6, можно умножить `u` на 6, преобразовать к целому, а потом добавить 1.

   Это работает, потому что `u` равномерно распределено на [0,1], и умножение на 6 даст равномерное распределение на [0,6]. После преобразования к целому (отбрасывание дробной части) и добавления 1, получим равномерное распределение на [1,6].

   ```{python}
   dice_rolls = (u * 6).astype(int) + 1
   ```

   Здесь, метод `astype(int)` преобразует массив в целочисленный тип, а `+ 1` добавляет 1 к каждому элементу.

5. **Проверим частоты для кубика**:

   ```{python}
   for face in range(1, 7):
       count = np.sum(dice_rolls == face)
       print(f"Грань {face}: {count}")
   ```

---

## Задача 2: Построение гистограмм

**Цель:**  
Научиться строить гистограммы для дискретных исходов (результаты подбрасываний монетки и бросков кубика).

**Гистограмма** – это столбиковая диаграмма, показывающая как часто встречаются разные значения.

### Шаги

1. **Подключаем Matplotlib**:

   ```{python}
   import matplotlib.pyplot as plt
   ```

2. **Гистограмма для подбрасываний монетки**:

   Чтобы нарисовать гистограмму, используем [`matplotlib.pyplot.hist`](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.hist.html) с параметрами:

   - `coin_flips` – массив результатов подбрасываний.
   - `bins=[-0.5,0.5,1.5]` – границы столбцов (для 0 и 1).
   - `edgecolor='black'` – цвет границ столбцов.
   - `align='mid'` – выравнивание столбцов по центру.

   ```{python}
   plt.hist(coin_flips, bins=[-0.5,0.5,1.5], edgecolor='black', align='mid')
   plt.xticks([0,1], ["Орёл","Решка"])
   plt.title("Результаты подбрасывания монеты")
   plt.xlabel("Исход")
   plt.ylabel("Частота")
   plt.show()
   ```

3. **Гистограмма для бросков кубика**:

   ```{python}
   plt.hist(dice_rolls, bins=np.arange(0.5,7.5,1), edgecolor='black', align='mid')
   plt.xticks([1,2,3,4,5,6])
   plt.title("Результаты броска кубика")
   plt.xlabel("Исход")
   plt.ylabel("Частота")
   plt.show()
   ```

---

## Задача 3: Симуляция нормального распределения, гистограмма и плотность

**Цель:**

- Сгенерировать данные из нормального распределения с параметрами (среднее = 0, стандартное отклонение = 1).
- Построить гистограмму.
- Добавить теоретическую плотность нормального распределения (кривую).

### Пояснение

**Нормальное распределение** часто называют «колоколообразным». Метод [`numpy.random.default_rng().normal`](https://numpy.org/doc/stable/reference/random/generated/numpy.random.Generator.normal.html) генерирует случайные числа из нормального распределения с заданными параметрами.

Плотосноть нормального распределения с параметрами $\mu$ (среднее) и $\sigma$ (стандартное отклонение) обозначается как $N(\mu, \sigma^2)$ и задаётся формулой:

$$
f(x) = \frac{1}{\sqrt{2\pi}\sigma} e^{-\frac{(x-\mu)^2}{2\sigma^2}}.
$$

- `rng.normal()` генерирует случайное число из стандартного нормального распределения (среднее 0, стандартное отклонение 1).
- `rng.normal(loc=0, scale=1, size=1000)` генерирует 1000 чисел из стандартного нормального распределения (среднее 0, стандартное отклонение 1).

### Шаги

1. **Генерация нормальных данных**:

   ```{python}
   data = rng.normal(loc=0, scale=1, size=1000)  # N(0,1)
   ```

2. **Гистограмма с нормальными данными**:

   ```{python}
   plt.hist(data, bins=30, density=True, alpha=0.6, color='g', edgecolor='black')
   plt.title("Гистограмма нормального распределения")
   plt.xlabel("Значение")
   plt.ylabel("Плотность")
   plt.show()
   ```

   ::: {.callout-note}
   `density=True` нормализует гистограмму, чтобы площадь под ней была равна 1. Это позволяет сравнивать гистограмму с теоретической плотностью на одном графике.
   :::

3. **Добавление теоретической плотности**:

   Чтобы сравнить гистограмму с теоретической плотностью, нужно построить кривую плотности нормального распределения $N(0,1)$ на том же графике. Для этого используем модуль `scipy.stats.norm` и метод `pdf(x, loc=0, scale=1)` чтобы получить значения плотности $f(x)$ в точках `x`.

   ::: {.callout-caution}
   Убедитесь, что у вас установлен пакет `scipy`. Если нет, установите его с помощью команды в терминале

   ```bash
   pip install scipy
   ```

   или в PyCharm через интерфейс **Python Packages**.
   :::

   ```{python}
   from scipy.stats import norm

   x = np.linspace(-4,4,100)
   pdf = norm.pdf(x, loc=0, scale=1)

   plt.hist(data, bins=30, density=True, alpha=0.6, color='g', edgecolor='black')
   plt.plot(x, pdf, 'r-', lw=2)
   plt.title("Нормальное распределение с теоретической плотностью")
   plt.xlabel("Значение")
   plt.ylabel("Плотность")
   plt.show()
   ```

---

## Задача 4: Две нормальные выборки и две вершины

**Цель:**

- Сгенерировать две выборки из нормальных распределений с разными средними.
- Объединить их.
- Построить гистограмму и оценку плотности, чтобы увидеть две вершины.

### Шаги

1. **Генерация двух выборок**:
   - Первая: N(-2, 1)
   - Вторая: N(2, 1)

   ```{python}
   data1 = rng.normal(loc=-2, scale=1, size=1000)
   data2 = rng.normal(loc=2, scale=1, size=1000)
   combined_data = np.concatenate((data1, data2))
   ```

2. **Гистограмма объединённых данных**:

   ```{python}
   plt.hist(combined_data, bins=30, density=True, alpha=0.6, edgecolor='black')
   plt.title("Гистограмма объединённых данных")
   plt.xlabel("Значение")
   plt.ylabel("Плотность")
   plt.show()
   ```

3. **Оценка плотности ядром (KDE)**:

   Поскольку плотность объединённых данных имеет более сложное распределение по сравнению с ранее представленной $f(x)$, теоретическая плотность скомбинированных данных выражается другим способом. Поэтому, можно использовать оценку плотности ядром (**KDE**, Kernel Density Estimation) для аппроксимации плотности.

   Пример того, как работает KDE, показан на картике ниже:

   ![Сравнение гистограммы (слева) и ядерной оценки плотности (справа), построенных из тех же самых данных. 6 индивидуальных ядер показаны красными пунктирными линиями, ядерная оценка плотности показана синей кривой. Точки данных показаны чёрточками на ленточной диаграмме по горизонтальной оси. Источник: [Wikipedia (Ядерная оценка плотности)](https://ru.wikipedia.org/wiki/%D0%AF%D0%B4%D0%B5%D1%80%D0%BD%D0%B0%D1%8F_%D0%BE%D1%86%D0%B5%D0%BD%D0%BA%D0%B0_%D0%BF%D0%BB%D0%BE%D1%82%D0%BD%D0%BE%D1%81%D1%82%D0%B8).](https://upload.wikimedia.org/wikipedia/commons/thumb/4/41/Comparison_of_1D_histogram_and_KDE.png/750px-Comparison_of_1D_histogram_and_KDE.png)

   ::: {.callout-note}
   Нормальное распределение имеет *хорошие свойства*, которые в данном случае позволяют найти аналитическое выражение для объединённой плотности:

   $$
   f(x) = \frac{1}{2} \cdot \left( \frac{1}{\sqrt{2\pi}} e^{-\frac{(x+2)^2}{2}} + \frac{1}{\sqrt{2\pi}} e^{-\frac{(x-2)^2}{2}} \right).
   $$

   Однако, в общем случае, когда распределения более сложные, аналитическое выражение может быть сложным или невозможным. В таких случаях используют оценку плотности ядром.
   :::
   
   Для этого используем класс [`gaussian_kde`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.html) из модуля `scipy.stats` для оценки плотости Гауссовским ядром.

   ::: {.callout-note}
   Оценка плотности ядра (KDE) – это метод аппроксимации плотности вероятности случайной величины. Он использует ядерную функцию (обычно гауссовскую) для оценки плотности в каждой точке.

   Список наиболее популярных ядер предствлен в [Wikipedia: Ядро (статистика)](https://ru.wikipedia.org/wiki/%D0%AF%D0%B4%D1%80%D0%BE_(%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%81%D1%82%D0%B8%D0%BA%D0%B0)).
   :::

   - Создаём объект `kde = gaussian_kde(combined_data)`, который оценивает плотность данных.
   - Генерируем значения `x_vals` для построения кривой.
   - Получаем значения плотности `density_vals` в этих точках с помощью `kde(x_vals)`.
      - `kde(x_vals)` возвращает оценку плотности в точках `x`.
      - `kde.pdf(x_vals)` – аналогичный метод.

   ```{python}
   #| echo: true
   #| eval: true

   from scipy.stats import gaussian_kde

   kde = gaussian_kde(combined_data)
   x_vals = np.linspace(-6,6,200)
   density_vals = kde(x_vals)

   plt.hist(combined_data, bins=30, density=True, alpha=0.6, edgecolor='black')
   plt.plot(x_vals, density_vals, 'r-', lw=2)
   plt.title("Объединённое распределение с оценкой плотности")
   plt.xlabel("Значение")
   plt.ylabel("Плотность")
   plt.show()
   ```

---

## Итоги

В этом файле мы пошагово рассмотрели:

- Генерацию равномерных и нормальных случайных чисел.
- Использование равномерного распределения для моделирования дискретных исходов (монета, кубик).
- Построение гистограмм для наглядного представления частот или плотностей.
- Добавление теоретической кривой плотности для нормального распределения.
- Объединение двух нормальных выборок и анализ полученного распределения с использованием оценки плотности, чтобы увидеть две вершины.

Запуская эти примеры кода по очереди и изучая результаты, вы лучше поймёте, как работать со случайными данными и визуализировать их распределения.

## Ссылки

1. [Документация `numpy.random.default_rng()`](https://numpy.org/doc/stable/reference/random/generator.html)
2. [Документация `numpy.random.Generator.random()`](https://numpy.org/doc/stable/reference/random/generated/numpy.random.Generator.random.html)
3. [Документация `matplotlib.pyplot.hist`](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.hist.html)
4. [Документация `scipy.stats.norm`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.norm.html)
5. [Документация `scipy.stats.gaussian_kde`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.html)
6. [Статья на Википедии о ядерной оценке плотности](https://ru.wikipedia.org/wiki/%D0%AF%D0%B4%D0%B5%D1%80%D0%BD%D0%B0%D1%8F_%D0%BE%D1%86%D0%B5%D0%BD%D0%BA%D0%B0_%D0%BF%D0%BB%D0%BE%D1%82%D0%BD%D0%BE%D1%81%D1%82%D0%B8)
7. [Статья на Википедии о нормальном распределении](https://ru.wikipedia.org/wiki/%D0%9D%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5)
